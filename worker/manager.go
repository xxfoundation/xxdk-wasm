////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2022 xx foundation                                             //
//                                                                            //
// Use of this source code is governed by a license that can be found in the  //
// LICENSE file.                                                              //
////////////////////////////////////////////////////////////////////////////////

//go:build js && wasm

package worker

import (
	"sync"
	"syscall/js"
	"time"

	"github.com/hack-pad/safejs"
	"github.com/pkg/errors"
)

// initID is the ID for the first item in the callback list. If the list only
// contains one callback, then this is the ID of that callback. If the list has
// autogenerated unique IDs, this is the initial ID to start at.
const initID = uint64(0)

// Response timeouts.
const (
	// workerInitialConnectionTimeout is the time to wait to receive initial
	// contact from a new worker before timing out.
	workerInitialConnectionTimeout = 90 * time.Second
)

// Manager manages the handling of messages received from the worker.
type Manager struct {
	mm *MessageManager

	// Wrapper of the Worker Javascript object.
	// Doc: https://developer.mozilla.org/en-US/docs/Web/API/Worker
	w Worker
}

// Keep track of all managers created so that they can be stopped
// by the main WASM thread
type ManagersTracker struct {
	tracked map[int]*Manager
	count   int
	mux     sync.Mutex
}

// Only add managers locally
func (mt *ManagersTracker) add(m *Manager) {
	mt.mux.Lock()
	defer mt.mux.Unlock()

	id := mt.count
	mt.count++

	mt.tracked[id] = m
}

// Stop all managers except logger
func (mt *ManagersTracker) Stop() {
	mt.mux.Lock()
	defer mt.mux.Unlock()
	for id, m := range mt.tracked {
		name := m.Name()
		if name == "xxdkLogFileWorker-main" {
			// Don't stop the logfile manager
			continue
		}
		m.Stop()
		delete(mt.tracked, id)
	}
}

var Tracker = &ManagersTracker{
	tracked: make(map[int]*Manager),
	count:   0,
}

// NewManager generates a new Manager. This functions will only return once
// communication with the worker has been established.
func NewManager(aURL, name string, messageLogging bool) (*Manager, error) {
	w, err := NewWorker(aURL, newWorkerOptions("", "", name))
	if err != nil {
		return nil, errors.Wrapf(err, "failed to construct Worker")
	}

	p := DefaultParams()
	p.MessageLogging = messageLogging
	mm, err := NewMessageManager(w.Value, name+"-main", p)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to construct message manager")
	}

	m := &Manager{
		mm: mm,
		w:  w,
	}

	Tracker.add(m)

	// Register a callback that will receive initial message from worker
	// indicating that it is ready
	ready := make(chan struct{})
	mm.RegisterCallback(readyTag, func([]byte, func([]byte)) {
		ready <- struct{}{}
	})

	// Wait for the ready signal from the worker
	select {
	case <-ready:
	case <-time.After(workerInitialConnectionTimeout):
		return nil, errors.Errorf("[WW] [%s] timed out after %s waiting for "+
			"initial message from worker",
			mm.name, workerInitialConnectionTimeout)
	}

	return m, nil
}

// NewManagerFromScript generates a new Manager. This functions will only return
// once communication with the worker has been established.
// TODO: test or remove
func NewManagerFromScript(
	jsScript, name string, messageLogging bool) (*Manager, error) {

	blob, err := jsBlob.New([]any{jsScript}, map[string]any{
		"type": "text/javascript",
	})
	if err != nil {
		return nil, err
	}
	objectURL, err := jsURL.Call("createObjectURL", blob)
	if err != nil {
		return nil, err
	}
	objectURLStr, err := objectURL.String()
	if err != nil {
		return nil, err
	}

	return NewManager(objectURLStr, name, messageLogging)
}

// Stop closes the worker manager and terminates the worker.
func (m *Manager) Stop() error {
	m.mm.Stop()

	// Terminate the worker
	err := m.w.Terminate()
	return errors.Wrapf(err, "failed to terminate worker %q", m.mm.name)
}

// SendMessage sends a message to the worker with the given tag and waits for a
// response. An error is returned on failure to send or on timeout.
func (m *Manager) SendMessage(tag Tag, data []byte) (response []byte, err error) {
	return m.mm.Send(tag, data)
}

// SendTimeout sends a message to the worker with the given tag and waits for a
// response. An error is returned on failure to send or on the specified
// timeout.
func (m *Manager) SendTimeout(
	tag Tag, data []byte, timeout time.Duration) (response []byte, err error) {
	return m.mm.SendTimeout(tag, data, timeout)
}

// SendNoResponse sends a message to the worker with the given tag. It returns
// immediately and does not wait for a response.
func (m *Manager) SendNoResponse(tag Tag, data []byte) error {
	return m.mm.SendNoResponse(tag, data)
}

// RegisterCallback registers the callback for the given tag. Previous tags are
// overwritten. This function is thread safe.
func (m *Manager) RegisterCallback(tag Tag, receiverCB ReceiverCallback) {
	m.mm.RegisterCallback(tag, receiverCB)
}

// GetWorker returns the Worker wrapper for the Worker Javascript object. This
// is returned so the worker object can be returned to the Javascript layer for
// it to communicate with the worker thread.
func (m *Manager) GetWorker() js.Value { return safejs.Unsafe(m.w.Value) }

// Name returns the name of the web worker object.
func (m *Manager) Name() string { return m.mm.name }

////////////////////////////////////////////////////////////////////////////////
// Worker Wrapper                                                             //
////////////////////////////////////////////////////////////////////////////////

// Worker wraps a Javascript Worker object.
//
// Doc: https://developer.mozilla.org/en-US/docs/Web/API/Worker
type Worker struct {
	MessagePort
}

var (
	jsWorker         = safejs.MustGetGlobal("Worker")
	jsMessageChannel = safejs.MustGetGlobal("MessageChannel")
	jsURL            = safejs.MustGetGlobal("URL")
	jsBlob           = safejs.MustGetGlobal("Blob")
)

// NewWorker creates a Javascript Worker object that executes the script at the
// specified URL.
//
// It returns any thrown exceptions as errors.
//
// Doc: https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker
func NewWorker(aURL string, options map[string]any) (w Worker, err error) {
	v, err := jsWorker.New(aURL, options)
	if err != nil {
		return Worker{}, err
	}

	mp, err := NewMessagePort(v)
	if err != nil {
		return Worker{}, err
	}

	return Worker{MessagePort: mp}, nil
}

// Terminate immediately terminates the Worker. This does not offer the worker
// an opportunity to finish its operations; it is stopped at once.
//
// Doc: https://developer.mozilla.org/en-US/docs/Web/API/Worker/terminate
func (w Worker) Terminate() error {
	_, err := w.Call("terminate")
	return err
}

// newWorkerOptions creates a new Javascript object containing optional
// properties that can be set when creating a new worker.
//
// Each property is optional; leave a property empty to use the defaults (as
// documented). The available properties are:
//   - workerType - The type of worker to create. The value can be either
//     "classic" or "module". If not specified, the default used is "classic".
//   - credentials - The type of credentials to use for the worker. The value
//     can be "omit", "same-origin", or "include". If it is not specified, or if
//     the type is "classic", then the default used is "omit" (no credentials
//     are required).
//   - name - An identifying name for the worker, used mainly for debugging
//     purposes.
//
// Doc: https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker#options
func newWorkerOptions(workerType, credentials, name string) map[string]any {
	options := make(map[string]any, 3)
	if workerType != "" {
		options["type"] = workerType
	}
	if credentials != "" {
		options["credentials"] = credentials
	}
	if name != "" {
		options["name"] = name
	}
	return options
}
